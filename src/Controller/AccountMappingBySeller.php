<?php

namespace App\Controller;

use App\Entity\AccountMapping;
use App\Repository\AccountMappingRepository;
use App\Repository\AccountOnboardingRepository;
use App\Service\StripeClient;
use Psr\Log\LoggerAwareInterface;
use Psr\Log\LoggerAwareTrait;
use Stripe\Exception\ApiErrorException;
use Swagger\Annotations as SWG;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\RedirectResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

class AccountMappingBySeller extends AbstractController implements LoggerAwareInterface
{
    use LoggerAwareTrait;

    public const ERROR_MISSING_CODE = [
        'code' => 'missing_code',
        'description' => 'Stripe provided no code',
    ];
    public const ERROR_MISSING_STATE = [
        'code' => 'missing_state',
        'description' => 'Stripe provided no state',
    ];
    public const ERROR_NO_MATCHING_STATE = [
        'code' => 'no_matching_state',
        'description' => 'Could not find matching state',
    ];
    public const ERROR_ALREADY_EXISTING_SHOP = [
        'code' => 'already_existing_shop',
        'description' => 'Mirakl shop already exists',
    ];

    /**
     * @var StripeClient
     */
    private $stripeClient;

    /**
     * @var string
     */
    private $redirectOnboarding;

    /**
     * @var AccountMappingRepository
     */
    private $accountMappingRepository;

    /**
     * @var AccountOnboardingRepository
     */
    private $accountOnboardingRepository;

    public function __construct(
        StripeClient $stripeClient,
        string $redirectOnboarding,
        AccountMappingRepository $accountMappingRepository,
        AccountOnboardingRepository $accountOnboardingRepository
    ) {
        $this->stripeClient = $stripeClient;
        $this->redirectOnboarding = $redirectOnboarding;
        $this->accountMappingRepository = $accountMappingRepository;
        $this->accountOnboardingRepository = $accountOnboardingRepository;
    }

    private function getRedirectResponse(array $error): RedirectResponse
    {
        $this->logger->error('Could not process return from Stripe', $error);

        $queryParams = \http_build_query([
            'error' => 'true',
            'error_code' => $error['code'],
            'error_description' => $error['description'],
        ]);
        $redirectOnboardingWithShop = sprintf('%s?%s', $this->redirectOnboarding, $queryParams);

        return new RedirectResponse($redirectOnboardingWithShop);
    }

    /**
     * Creates the Stripe-Mirakl mapping.
     * Should only be called via the Stripe Connect redirect URI.
     *
     * @SWG\Parameter(
     *     name="code",
     *     in="query",
     *     type="string",
     *     description="The code generated by Stripe which allows us to fetch seller info"
     * )
     * @SWG\Parameter(
     *     name="state",
     *     in="query",
     *     type="string",
     *     description="The random state generated using /api/onboarding/{miraklId} route"
     * )
     * @SWG\Response(
     *     response=302,
     *     description="Redirect to REDIRECT_ONBOARDING with extra query parameters. See <a target = '_blank' href='https://stripe.com/docs/plugins/mirakl/onboarding-sellers'>documentation</a>"
     * )
     * @SWG\Response(
     *     response=400,
     *     description="Stripe could not create the account",
     * )
     * @SWG\Response(
     *     response=404,
     *     description="The provided state does not match any known account",
     * )
     * @SWG\Response(
     *     response=409,
     *     description="Mirakl Shop ID is already linked to a Stripe Connect account",
     * )
     * @SWG\Tag(name="Internal (Stripe Only)")
     * @Route("/api/public/onboarding/create_mapping", methods={"GET"}, name="create_mapping")
     */
    public function linkShop(Request $request): Response
    {
        $code = $request->query->get('code');
        $state = $request->query->get('state');

        if (null === $code) {
            return $this->getRedirectResponse(self::ERROR_MISSING_CODE);
        }

        if (null === $state) {
            return $this->getRedirectResponse(self::ERROR_MISSING_STATE);
        }

        $accountOnboarding = $this->accountOnboardingRepository->findOneByStripeState($state);

        if (null === $accountOnboarding) {
            return $this->getRedirectResponse(self::ERROR_NO_MATCHING_STATE);
        }

        $miraklShopId = $accountOnboarding->getMiraklShopId();
        assert(null !== $miraklShopId);

        $this->accountOnboardingRepository->deleteAndFlush($accountOnboarding);
        $existingShop = $this->accountMappingRepository->findOneByMiraklShopId($miraklShopId);
        if ($existingShop) {
            return $this->getRedirectResponse(self::ERROR_ALREADY_EXISTING_SHOP);
        }

        try {
            $response = $this->stripeClient->loginWithCode($code);
            $stripeUserId = $response->stripe_user_id;
            $stripeAccount = $this->stripeClient->setPayoutToManual($stripeUserId);
        } catch (ApiErrorException $e) {
            return $this->getRedirectResponse([
                'code' => $e->getStripeCode(),
                'description' => $e->getMessage(),
            ]);
        }

        $mapping = new AccountMapping();
        $mapping->setMiraklShopId($miraklShopId);
        $mapping->setStripeAccountId($stripeUserId);
        $mapping->setPayoutEnabled($stripeAccount->payouts_enabled);
        $mapping->setDisabledReason($stripeAccount->requirements->disabled_reason);
        $mapping->setPayinEnabled($stripeAccount->charges_enabled);

        $this->accountMappingRepository->persistAndFlush($mapping);

        $queryParams = \http_build_query([
            'success' => 'true',
            'mirakl_shop_id' => $miraklShopId,
        ]);
        $redirectOnboardingWithShop = sprintf('%s?%s', $this->redirectOnboarding, $queryParams);

        $this->logger->info(sprintf('Redirecting Shop Owner %s to success or next step', $miraklShopId));

        return new RedirectResponse($redirectOnboardingWithShop);
    }
}
